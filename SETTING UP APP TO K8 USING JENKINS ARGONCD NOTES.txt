
Example :
```
# Purpose: ACME issuer to request Let's Encrypt TLS certificates.
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: production-app
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: demo@v1.com
    privateKeySecretRef:
      name: app
    solvers:
      - http01:
          ingress:
            class: nginx
---
# Purpose: Request TLS certificate for the domain.
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: app
spec:
  secretName: app
  issuerRef:
    name: production-app
    kind: ClusterIssuer
  commonName: demo.kubesimplify.com
  dnsNames:
    - demo.kubesimplify.com
---
# Purpose: Expose the application to the internet using HTTP/HTTPS.
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: task-app-ingress
  annotations:
    cert-manager.io/cluster-issuer: production-app
spec:
  ingressClassName: nginx
  rules:
    - host: demo.kubesimplify.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: task-app-service
                port:
                  number: 80
  tls:
    - hosts:
        - demo.kubesimplify.com
      secretName: app

```


âœ… 1. ClusterIssuer â€” â€œThe Person Who Gives You Certificatesâ€

ğŸ“Œ What it is ClusterIssuer
A ClusterIssuer is like a certificate provider inside your Kubernetes cluster.

It tells Kubernetes:
â€œWhen I need an HTTPS certificate, go to Letâ€™s Encrypt,
and request it using this email, this server, and validate through NGINX Ingress.â€

ğŸ“Œ Why it's needed
Without it, Kubernetes cannot get free SSL/TLS certificates from Letâ€™s Encrypt.

ğŸ“Œ Where it is used
It is not used by your application directly.
It is used by cert-manager + Ingress to create HTTPS certs.

Install CERT MANAGER
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.5/cert-manager.yaml

Install Metrics server
kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml


ğŸ“Œ How it works (simple example)
Think of Issuer as a passport office.

You say: I want a passport (TLS certificate).

Issuer replies: Ok, I will request it from Letâ€™s Encrypt, verify it, and then give you the passport (certificate).

example :
kind: ClusterIssuer
metadata:
  name: production-app

This means:
â€œA global (cluster-wide) certificate provider named production-app.â€


âœ… 2. Certificate â€” â€œThe Actual SSL Certificate You Are Asking Forâ€
ğŸ“Œ What it is
A Certificate resource requests an actual SSL certificate for a domain.

from above example : demo.kubesimplify.com


ğŸ“Œ Where it is used
It is used by the Ingress to serve HTTPS.

ğŸ“Œ How it works (simple example)

Think of Certificate as your application asking for a passport:

â€œHey ClusterIssuer, please create a certificate for my domain
demo.kubesimplify.com
and store it in a secret named app.â€

The ClusterIssuer then goes to Letâ€™s Encrypt, validates the domain, and stores certificate in:
Secret: app

ğŸ‘‰ In YAML:
spec:
  secretName: app
  issuerRef:
    name: production-app

This means:
Store the generated certificate in a Kubernetes secret named app,
signed by the ClusterIssuer production-app.

Your Ingress will use this secret to enable HTTPS.



ğŸ”’ 3. How These Two Are Used in Your Deployment
Your Deployment does NOT directly use these objects.

Your Ingress uses them to enable HTTPS.

Flow:

1ï¸âƒ£ ClusterIssuer
Tells Kubernetes how to talk to Letâ€™s Encrypt.

2ï¸âƒ£ Certificate
Requests a certificate for demo.kubesimplify.com.

3ï¸âƒ£ cert-manager
Contacts Letâ€™s Encrypt â†’ validates â†’ gets the cert â†’ stores in secret.

4ï¸âƒ£ Ingress
Uses:
tls:
  - hosts:
      - demo.kubesimplify.com
    secretName: app

This secret was created by the Certificate.

5ï¸âƒ£ Browser sees HTTPS is secure


Imagine your app is reachable at: http://demo.kubesimplify.com
But you want: https://demo.kubesimplify.com   (secure)

Step-by-step:

Step 1 â€” ClusterIssuer
ClusterIssuer tells cert-manager:
â€œUse Letâ€™s Encrypt to get certificates when someone requests one.â€

Step 2 â€” Certificate
Certificate says:
â€œI need an SSL certificate for demo.kubesimplify.com.â€

Step 3 â€” Validation
Letâ€™s Encrypt checks domain ownership using NGINX Ingress (HTTP-01 challenge).

Step 4 â€” cert-manager stores cert in Secret
Certificate is stored inside: Secret: app

Step 5 â€” Ingress uses certificate
Your Ingress config references that secret: secretName: app

Now HTTPS works.


ğŸ”— 5. How It Fits into Your Jenkins File + GitOps Pipeline
âœ” Jenkins builds app â†’ builds docker image
âœ” Jenkins updates manifest repo with new image tag
âœ” ArgoCD notices change â†’ deploys updated Deployment
âœ” Ingress stays same but continues using TLS certificate
âœ” cert-manager renews certificate automatically (every 60â€“90 days)

No changes needed in Jenkins â€”
cert-manager handles SSL automatically.


ğŸ§  Why This Is Important
Without ClusterIssuer + Certificate

âŒ Your domain won't have HTTPS
âŒ Browsers show â€œNot Secureâ€
âŒ Some APIs wonâ€™t work
âŒ OAuth2 / JWT redirects break
âŒ Production websites are insecure

With ClusterIssuer + Certificate

âœ… Automatic Letâ€™s Encrypt HTTPS
âœ… Automatic renewal
âœ… No manual certificate installation
âœ… Secure production-ready traffic
âœ… Fully GitOps automated


âœ… Does the Certificate store the generated certificate?
Not directly.The Certificate object does NOT store the certificate inside itself. It tells cert-manager where to store the
certificate.
That location is: âœ” The Kubernetes Secret mentioned in: secretName: app
So cert-manager will create a Secret:
And inside that Secret cert-manager will store:
tls.crt â†’ The actual TLS certificate
tls.key â†’ The private key
ca.crt â†’ (Sometimes) CA certificate


2ï¸âƒ£ Secret (created automatically)
This is the actual storage:
apiVersion: v1
kind: Secret
metadata:
  name: app
type: kubernetes.io/tls
data:
  tls.crt: <base64 encoded certificate>
  tls.key: <base64 private key>


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Here is a complete, working Kubernetes setup using nip.io, fully compatible with your Jenkins CI/CD pipeline â€” NO domain needed, NO HTTPS, NO cert-manager, ONLY Ingress + LoadBalancer + nip.io auto-DNS.

âœ… COMPLETE FREE SETUP USING nip.io (NO HTTPS)
You only need:
Kubernetes cluster
Ingress-NGINX installed
LoadBalancer external IP
nip.io to auto-resolve domain



argocd :::
kubectl port-forward svc/argocd-server -n argocd 8080:443
kubectl port-forward [resource] [LOCAL_PORT:]REMOTE_PORT

kubectl port-forward svc/argocd-server -n argocd 9090:443


using ngrok :
since jenkins running on 8080 port so run ngrok command on ubuntu terminal where jenkins is running as service
ngrok http 8080
output will give something like this :::  https://bfab2131b3c4.ngrok-free.app

before adding into github append above linke with : "/github-webhook/"

SO NOW LINK Will BE LIKE THIS : https://bfab2131b3c4.ngrok-free.app/github-webhook/
https://4bd4873f84dd.ngrok-free.app/github-webhook/


sonarqube-jenkins webhook :
https://4bd4873f84dd.ngrok-free.app/sonarqube-webhook/
https://bfab2131b3c4.ngrok-free.app/sonarqube-webhook/



































































































































